{"ast":null,"code":"import _regeneratorRuntime from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\n\nvar PrecacheController = /*#__PURE__*/function () {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] The cache to use for precaching.\n   * @param {string} [options.plugins] Plugins to use when precaching as well\n   * as responding to fetch events for precached assets.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  function PrecacheController() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        cacheName = _ref.cacheName,\n        _ref$plugins = _ref.plugins,\n        plugins = _ref$plugins === void 0 ? [] : _ref$plugins,\n        _ref$fallbackToNetwor = _ref.fallbackToNetwork,\n        fallbackToNetwork = _ref$fallbackToNetwor === void 0 ? true : _ref$fallbackToNetwor;\n\n    _classCallCheck(this, PrecacheController);\n\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n    this._strategy = new PrecacheStrategy({\n      cacheName: cacheNames.getPrecacheName(cacheName),\n      plugins: [].concat(_toConsumableArray(plugins), [new PrecacheCacheKeyPlugin({\n        precacheController: this\n      })]),\n      fallbackToNetwork: fallbackToNetwork\n    }); // Bind the install and activate methods to the instance.\n\n    this.install = this.install.bind(this);\n    this.activate = this.activate.bind(this);\n  }\n  /**\n   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n   * used to cache assets and respond to fetch events.\n   */\n\n\n  _createClass(PrecacheController, [{\n    key: \"strategy\",\n    get: function get() {\n      return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n\n  }, {\n    key: \"precache\",\n    value: function precache(entries) {\n      this.addToCacheList(entries);\n\n      if (!this._installAndActiveListenersAdded) {\n        self.addEventListener('install', this.install);\n        self.addEventListener('activate', this.activate);\n        this._installAndActiveListenersAdded = true;\n      }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n\n  }, {\n    key: \"addToCacheList\",\n    value: function addToCacheList(entries) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(entries, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'addToCacheList',\n          paramName: 'entries'\n        });\n      }\n\n      var urlsToWarnAbout = [];\n\n      var _iterator = _createForOfIteratorHelper(entries),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n\n          // See https://github.com/GoogleChrome/workbox/issues/2259\n          if (typeof entry === 'string') {\n            urlsToWarnAbout.push(entry);\n          } else if (entry && entry.revision === undefined) {\n            urlsToWarnAbout.push(entry.url);\n          }\n\n          var _createCacheKey = createCacheKey(entry),\n              cacheKey = _createCacheKey.cacheKey,\n              url = _createCacheKey.url;\n\n          var cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n\n          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n            throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n              firstEntry: this._urlsToCacheKeys.get(url),\n              secondEntry: cacheKey\n            });\n          }\n\n          if (typeof entry !== 'string' && entry.integrity) {\n            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                url: url\n              });\n            }\n\n            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n          }\n\n          this._urlsToCacheKeys.set(url, cacheKey);\n\n          this._urlsToCacheModes.set(url, cacheMode);\n\n          if (urlsToWarnAbout.length > 0) {\n            var warningMessage = \"Workbox is precaching URLs without revision \" + \"info: \".concat(urlsToWarnAbout.join(', '), \"\\nThis is generally NOT safe. \") + \"Learn more at https://bit.ly/wb-precache\";\n\n            if (process.env.NODE_ENV === 'production') {\n              // Use console directly to display this warning without bloating\n              // bundle sizes by pulling in all of the logger codebase in prod.\n              console.warn(warningMessage);\n            } else {\n              logger.warn(warningMessage);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n\n  }, {\n    key: \"install\",\n    value: function install(event) {\n      var _this = this;\n\n      // waitUntil returns Promise<any>\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return waitUntil(event, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var installReportPlugin, _iterator2, _step2, _step2$value, url, cacheKey, integrity, cacheMode, request, updatedURLs, notUpdatedURLs;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                installReportPlugin = new PrecacheInstallReportPlugin();\n\n                _this.strategy.plugins.push(installReportPlugin); // Cache entries one at a time.\n                // See https://github.com/GoogleChrome/workbox/issues/2528\n\n\n                _iterator2 = _createForOfIteratorHelper(_this._urlsToCacheKeys);\n                _context.prev = 3;\n\n                _iterator2.s();\n\n              case 5:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 14;\n                  break;\n                }\n\n                _step2$value = _slicedToArray(_step2.value, 2), url = _step2$value[0], cacheKey = _step2$value[1];\n                integrity = _this._cacheKeysToIntegrities.get(cacheKey);\n                cacheMode = _this._urlsToCacheModes.get(url);\n                request = new Request(url, {\n                  integrity: integrity,\n                  cache: cacheMode,\n                  credentials: 'same-origin'\n                });\n                _context.next = 12;\n                return Promise.all(_this.strategy.handleAll({\n                  params: {\n                    cacheKey: cacheKey\n                  },\n                  request: request,\n                  event: event\n                }));\n\n              case 12:\n                _context.next = 5;\n                break;\n\n              case 14:\n                _context.next = 19;\n                break;\n\n              case 16:\n                _context.prev = 16;\n                _context.t0 = _context[\"catch\"](3);\n\n                _iterator2.e(_context.t0);\n\n              case 19:\n                _context.prev = 19;\n\n                _iterator2.f();\n\n                return _context.finish(19);\n\n              case 22:\n                updatedURLs = installReportPlugin.updatedURLs, notUpdatedURLs = installReportPlugin.notUpdatedURLs;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  printInstallDetails(updatedURLs, notUpdatedURLs);\n                }\n\n                return _context.abrupt(\"return\", {\n                  updatedURLs: updatedURLs,\n                  notUpdatedURLs: notUpdatedURLs\n                });\n\n              case 25:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3, 16, 19, 22]]);\n      })));\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n\n  }, {\n    key: \"activate\",\n    value: function activate(event) {\n      var _this2 = this;\n\n      // waitUntil returns Promise<any>\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return waitUntil(event, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var cache, currentlyCachedRequests, expectedCacheKeys, deletedURLs, _iterator3, _step3, request;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return self.caches.open(_this2.strategy.cacheName);\n\n              case 2:\n                cache = _context2.sent;\n                _context2.next = 5;\n                return cache.keys();\n\n              case 5:\n                currentlyCachedRequests = _context2.sent;\n                expectedCacheKeys = new Set(_this2._urlsToCacheKeys.values());\n                deletedURLs = [];\n                _iterator3 = _createForOfIteratorHelper(currentlyCachedRequests);\n                _context2.prev = 9;\n\n                _iterator3.s();\n\n              case 11:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                request = _step3.value;\n\n                if (expectedCacheKeys.has(request.url)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                _context2.next = 16;\n                return cache.delete(request);\n\n              case 16:\n                deletedURLs.push(request.url);\n\n              case 17:\n                _context2.next = 11;\n                break;\n\n              case 19:\n                _context2.next = 24;\n                break;\n\n              case 21:\n                _context2.prev = 21;\n                _context2.t0 = _context2[\"catch\"](9);\n\n                _iterator3.e(_context2.t0);\n\n              case 24:\n                _context2.prev = 24;\n\n                _iterator3.f();\n\n                return _context2.finish(24);\n\n              case 27:\n                if (process.env.NODE_ENV !== 'production') {\n                  printCleanupDetails(deletedURLs);\n                }\n\n                return _context2.abrupt(\"return\", {\n                  deletedURLs: deletedURLs\n                });\n\n              case 29:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[9, 21, 24, 27]]);\n      })));\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n\n  }, {\n    key: \"getURLsToCacheKeys\",\n    value: function getURLsToCacheKeys() {\n      return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n\n  }, {\n    key: \"getCachedURLs\",\n    value: function getCachedURLs() {\n      return _toConsumableArray(this._urlsToCacheKeys.keys());\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n\n  }, {\n    key: \"getCacheKeyForURL\",\n    value: function getCacheKeyForURL(url) {\n      var urlObject = new URL(url, location.href);\n      return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n\n  }, {\n    key: \"getIntegrityForCacheKey\",\n    value: function getIntegrityForCacheKey(cacheKey) {\n      return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n\n  }, {\n    key: \"matchPrecache\",\n    value: function () {\n      var _matchPrecache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {\n        var url, cacheKey, cache;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                url = request instanceof Request ? request.url : request;\n                cacheKey = this.getCacheKeyForURL(url);\n\n                if (!cacheKey) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                _context3.next = 5;\n                return self.caches.open(this.strategy.cacheName);\n\n              case 5:\n                cache = _context3.sent;\n                return _context3.abrupt(\"return\", cache.match(cacheKey));\n\n              case 7:\n                return _context3.abrupt(\"return\", undefined);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function matchPrecache(_x) {\n        return _matchPrecache.apply(this, arguments);\n      }\n\n      return matchPrecache;\n    }()\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n\n  }, {\n    key: \"createHandlerBoundToURL\",\n    value: function createHandlerBoundToURL(url) {\n      var _this3 = this;\n\n      var cacheKey = this.getCacheKeyForURL(url);\n\n      if (!cacheKey) {\n        throw new WorkboxError('non-precached-url', {\n          url: url\n        });\n      }\n\n      return function (options) {\n        options.request = new Request(url);\n        options.params = Object.assign({\n          cacheKey: cacheKey\n        }, options.params);\n        return _this3.strategy.handle(options);\n      };\n    }\n  }]);\n\n  return PrecacheController;\n}();\n\nexport { PrecacheController };","map":{"version":3,"names":["assert","cacheNames","logger","WorkboxError","waitUntil","createCacheKey","PrecacheInstallReportPlugin","PrecacheCacheKeyPlugin","printCleanupDetails","printInstallDetails","PrecacheStrategy","PrecacheController","cacheName","plugins","fallbackToNetwork","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","_strategy","getPrecacheName","precacheController","install","bind","activate","entries","addToCacheList","_installAndActiveListenersAdded","self","addEventListener","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","entry","push","revision","undefined","url","cacheKey","cacheMode","has","get","firstEntry","secondEntry","integrity","set","length","warningMessage","join","console","warn","event","installReportPlugin","strategy","request","Request","cache","credentials","Promise","all","handleAll","params","updatedURLs","notUpdatedURLs","caches","open","keys","currentlyCachedRequests","expectedCacheKeys","Set","values","deletedURLs","delete","urlObject","URL","location","href","getCacheKeyForURL","match","options","Object","assign","handle"],"sources":["/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/workbox-precaching/PrecacheController.js"],"sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] The cache to use for precaching.\n     * @param {string} [options.plugins] Plugins to use when precaching as well\n     * as responding to fetch events for precached assets.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n            cacheName: cacheNames.getPrecacheName(cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({ precacheController: this }),\n            ],\n            fallbackToNetwork,\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n    }\n    /**\n     * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n     * used to cache assets and respond to fetch events.\n     */\n    get strategy() {\n        return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n    precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n            self.addEventListener('install', this.install);\n            self.addEventListener('activate', this.activate);\n            this._installAndActiveListenersAdded = true;\n        }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n    install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.strategy.plugins.push(installReportPlugin);\n            // Cache entries one at a time.\n            // See https://github.com/GoogleChrome/workbox/issues/2528\n            for (const [url, cacheKey] of this._urlsToCacheKeys) {\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: 'same-origin',\n                });\n                await Promise.all(this.strategy.handleAll({\n                    params: { cacheKey },\n                    request,\n                    event,\n                }));\n            }\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (process.env.NODE_ENV !== 'production') {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return { updatedURLs, notUpdatedURLs };\n        });\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n    activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedURLs = [];\n            for (const request of currentlyCachedRequests) {\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedURLs.push(request.url);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                printCleanupDetails(deletedURLs);\n            }\n            return { deletedURLs };\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n    getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        return (options) => {\n            options.request = new Request(url);\n            options.params = Object.assign({ cacheKey }, options.params);\n            return this.strategy.handle(options);\n        };\n    }\n}\nexport { PrecacheController };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}