{"ast":null,"code":"import _slicedToArray from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\n\nvar PrecacheStrategy = /*#__PURE__*/function (_Strategy) {\n  _inherits(PrecacheStrategy, _Strategy);\n\n  var _super = _createSuper(PrecacheStrategy);\n\n  /**\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n   * of all fetch() requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  function PrecacheStrategy() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PrecacheStrategy);\n\n    options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n    _this = _super.call(this, options);\n    _this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true; // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n\n    _this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n\n    return _this;\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n\n\n  _createClass(PrecacheStrategy, [{\n    key: \"_handle\",\n    value: function () {\n      var _handle2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, handler) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return handler.cacheMatch(request);\n\n              case 2:\n                response = _context.sent;\n\n                if (!response) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", response);\n\n              case 5:\n                if (!(handler.event && handler.event.type === 'install')) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 8;\n                return this._handleInstall(request, handler);\n\n              case 8:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 9:\n                _context.next = 11;\n                return this._handleFetch(request, handler);\n\n              case 11:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _handle(_x, _x2) {\n        return _handle2.apply(this, arguments);\n      }\n\n      return _handle;\n    }()\n  }, {\n    key: \"_handleFetch\",\n    value: function () {\n      var _handleFetch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request, handler) {\n        var response, params, integrityInManifest, integrityInRequest, noIntegrityConflict, wasCached, cacheKey;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                params = handler.params || {}; // Fall back to the network if we're configured to do so.\n\n                if (!this._fallbackToNetwork) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.warn(\"The precached response for \" + \"\".concat(getFriendlyURL(request.url), \" in \").concat(this.cacheName, \" was not \") + \"found. Falling back to the network.\");\n                }\n\n                integrityInManifest = params.integrity;\n                integrityInRequest = request.integrity;\n                noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n                _context2.next = 8;\n                return handler.fetch(new Request(request, {\n                  integrity: integrityInRequest || integrityInManifest\n                }));\n\n              case 8:\n                response = _context2.sent;\n\n                if (!(integrityInManifest && noIntegrityConflict)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                this._useDefaultCacheabilityPluginIfNeeded();\n\n                _context2.next = 13;\n                return handler.cachePut(request, response.clone());\n\n              case 13:\n                wasCached = _context2.sent;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  if (wasCached) {\n                    logger.log(\"A response for \".concat(getFriendlyURL(request.url), \" \") + \"was used to \\\"repair\\\" the precache.\");\n                  }\n                }\n\n              case 15:\n                _context2.next = 18;\n                break;\n\n              case 17:\n                throw new WorkboxError('missing-precache-entry', {\n                  cacheName: this.cacheName,\n                  url: request.url\n                });\n\n              case 18:\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                _context2.t0 = params.cacheKey;\n\n                if (_context2.t0) {\n                  _context2.next = 24;\n                  break;\n                }\n\n                _context2.next = 23;\n                return handler.getCacheKey(request, 'read');\n\n              case 23:\n                _context2.t0 = _context2.sent;\n\n              case 24:\n                cacheKey = _context2.t0;\n                // Workbox is going to handle the route.\n                // print the routing details to the console.\n                logger.groupCollapsed(\"Precaching is responding to: \" + getFriendlyURL(request.url));\n                logger.log(\"Serving the precached url: \".concat(getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)));\n                logger.groupCollapsed(\"View request details here.\");\n                logger.log(request);\n                logger.groupEnd();\n                logger.groupCollapsed(\"View response details here.\");\n                logger.log(response);\n                logger.groupEnd();\n                logger.groupEnd();\n\n              case 34:\n                return _context2.abrupt(\"return\", response);\n\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _handleFetch(_x3, _x4) {\n        return _handleFetch2.apply(this, arguments);\n      }\n\n      return _handleFetch;\n    }()\n  }, {\n    key: \"_handleInstall\",\n    value: function () {\n      var _handleInstall2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request, handler) {\n        var response, wasCached;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._useDefaultCacheabilityPluginIfNeeded();\n\n                _context3.next = 3;\n                return handler.fetch(request);\n\n              case 3:\n                response = _context3.sent;\n                _context3.next = 6;\n                return handler.cachePut(request, response.clone());\n\n              case 6:\n                wasCached = _context3.sent;\n\n                if (wasCached) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                throw new WorkboxError('bad-precaching-response', {\n                  url: request.url,\n                  status: response.status\n                });\n\n              case 9:\n                return _context3.abrupt(\"return\", response);\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _handleInstall(_x5, _x6) {\n        return _handleInstall2.apply(this, arguments);\n      }\n\n      return _handleInstall;\n    }()\n    /**\n     * This method is complex, as there a number of things to account for:\n     *\n     * The `plugins` array can be set at construction, and/or it might be added to\n     * to at any time before the strategy is used.\n     *\n     * At the time the strategy is used (i.e. during an `install` event), there\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\n     *\n     * - If this method is called and there are no suitable `cacheWillUpdate`\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n     *\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\n     * we don't have to do anything (this might be a previously added\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n     *\n     * - If this method is called and there is more than one `cacheWillUpdate`,\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n     * we need to remove it. (This situation is unlikely, but it could happen if\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\n     *\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_useDefaultCacheabilityPluginIfNeeded\",\n    value: function _useDefaultCacheabilityPluginIfNeeded() {\n      var defaultPluginIndex = null;\n      var cacheWillUpdatePluginCount = 0;\n\n      var _iterator = _createForOfIteratorHelper(this.plugins.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              index = _step$value[0],\n              plugin = _step$value[1];\n\n          // Ignore the copy redirected plugin when determining what to do.\n          if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n            continue;\n          } // Save the default plugin's index, in case it needs to be removed.\n\n\n          if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n            defaultPluginIndex = index;\n          }\n\n          if (plugin.cacheWillUpdate) {\n            cacheWillUpdatePluginCount++;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (cacheWillUpdatePluginCount === 0) {\n        this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n      } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n        // Only remove the default plugin; multiple custom plugins are allowed.\n        this.plugins.splice(defaultPluginIndex, 1);\n      } // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n\n    }\n  }]);\n\n  return PrecacheStrategy;\n}(Strategy);\n\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n  cacheWillUpdate: function cacheWillUpdate(_ref) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var response;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              response = _ref.response;\n\n              if (!(!response || response.status >= 400)) {\n                _context4.next = 3;\n                break;\n              }\n\n              return _context4.abrupt(\"return\", null);\n\n            case 3:\n              return _context4.abrupt(\"return\", response);\n\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }))();\n  }\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n  cacheWillUpdate: function cacheWillUpdate(_ref2) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n      var response;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              response = _ref2.response;\n\n              if (!response.redirected) {\n                _context5.next = 7;\n                break;\n              }\n\n              _context5.next = 4;\n              return copyResponse(response);\n\n            case 4:\n              _context5.t0 = _context5.sent;\n              _context5.next = 8;\n              break;\n\n            case 7:\n              _context5.t0 = response;\n\n            case 8:\n              return _context5.abrupt(\"return\", _context5.t0);\n\n            case 9:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }))();\n  }\n};\nexport { PrecacheStrategy };","map":{"version":3,"names":["copyResponse","cacheNames","getFriendlyURL","logger","WorkboxError","Strategy","PrecacheStrategy","options","cacheName","getPrecacheName","_fallbackToNetwork","fallbackToNetwork","plugins","push","copyRedirectedCacheableResponsesPlugin","request","handler","cacheMatch","response","event","type","_handleInstall","_handleFetch","params","process","env","NODE_ENV","warn","url","integrityInManifest","integrity","integrityInRequest","noIntegrityConflict","fetch","Request","_useDefaultCacheabilityPluginIfNeeded","cachePut","clone","wasCached","log","cacheKey","getCacheKey","groupCollapsed","groupEnd","status","defaultPluginIndex","cacheWillUpdatePluginCount","entries","index","plugin","defaultPrecacheCacheabilityPlugin","cacheWillUpdate","splice","redirected"],"sources":["/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/workbox-precaching/PrecacheStrategy.js"],"sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n    /**\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n     * of all fetch() requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork =\n            options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n            return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        const params = (handler.params || {});\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +\n                    `found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            response = await handler.fetch(new Request(request, {\n                integrity: integrityInRequest || integrityInManifest,\n            }));\n            // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n            // that the response matches the precache manifest's expectations,\n            // and there's either a) no integrity property in the incoming request\n            // or b) there is an integrity, and it matches the precache manifest.\n            // See https://github.com/GoogleChrome/workbox/issues/2858\n            if (integrityInManifest && noIntegrityConflict) {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (process.env.NODE_ENV !== 'production') {\n                    if (wasCached) {\n                        logger.log(`A response for ${getFriendlyURL(request.url)} ` +\n                            `was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        }\n        else {\n            // This shouldn't normally happen, but there are edge cases:\n            // https://github.com/GoogleChrome/workbox/issues/1441\n            throw new WorkboxError('missing-precache-entry', {\n                cacheName: this.cacheName,\n                url: request.url,\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            logger.groupCollapsed(`View request details here.`);\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupCollapsed(`View response details here.`);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            // Throwing here will lead to the `install` handler failing, which\n            // we want to do if *any* of the responses aren't safe to cache.\n            throw new WorkboxError('bad-precaching-response', {\n                url: request.url,\n                status: response.status,\n            });\n        }\n        return response;\n    }\n    /**\n     * This method is complex, as there a number of things to account for:\n     *\n     * The `plugins` array can be set at construction, and/or it might be added to\n     * to at any time before the strategy is used.\n     *\n     * At the time the strategy is used (i.e. during an `install` event), there\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\n     *\n     * - If this method is called and there are no suitable `cacheWillUpdate`\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n     *\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\n     * we don't have to do anything (this might be a previously added\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n     *\n     * - If this method is called and there is more than one `cacheWillUpdate`,\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n     * we need to remove it. (This situation is unlikely, but it could happen if\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\n     *\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n     *\n     * @private\n     */\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n            // Ignore the copy redirected plugin when determining what to do.\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            // Save the default plugin's index, in case it needs to be removed.\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        }\n        else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            // Only remove the default plugin; multiple custom plugins are allowed.\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n    }\n}\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n    async cacheWillUpdate({ response }) {\n        if (!response || response.status >= 400) {\n            return null;\n        }\n        return response;\n    },\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n    async cacheWillUpdate({ response }) {\n        return response.redirected ? await copyResponse(response) : response;\n    },\n};\nexport { PrecacheStrategy };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}