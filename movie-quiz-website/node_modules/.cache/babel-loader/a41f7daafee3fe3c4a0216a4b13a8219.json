{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _construct from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * The Router can be used to process a `FetchEvent` using one or more\n * {@link workbox-routing.Route}, responding with a `Response` if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox-routing\n */\n\nvar Router = /*#__PURE__*/function () {\n  /**\n   * Initializes a new Router.\n   */\n  function Router() {\n    _classCallCheck(this, Router);\n\n    this._routes = new Map();\n    this._defaultHandlerMap = new Map();\n  }\n  /**\n   * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n\n\n  _createClass(Router, [{\n    key: \"routes\",\n    get: function get() {\n      return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n\n  }, {\n    key: \"addFetchListener\",\n    value: function addFetchListener() {\n      var _this = this;\n\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('fetch', function (event) {\n        var request = event.request;\n\n        var responsePromise = _this.handleRequest({\n          request: request,\n          event: event\n        });\n\n        if (responsePromise) {\n          event.respondWith(responsePromise);\n        }\n      });\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"addCacheListener\",\n    value: function addCacheListener() {\n      var _this2 = this;\n\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('message', function (event) {\n        // event.data is type 'any'\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (event.data && event.data.type === 'CACHE_URLS') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          var payload = event.data.payload;\n\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(\"Caching URLs from the window\", payload.urlsToCache);\n          }\n\n          var requestPromises = Promise.all(payload.urlsToCache.map(function (entry) {\n            if (typeof entry === 'string') {\n              entry = [entry];\n            }\n\n            var request = _construct(Request, _toConsumableArray(entry));\n\n            return _this2.handleRequest({\n              request: request,\n              event: event\n            }); // TODO(philipwalton): TypeScript errors without this typecast for\n            // some reason (probably a bug). The real type here should work but\n            // doesn't: `Array<Promise<Response> | undefined>`.\n          })); // TypeScript\n\n          event.waitUntil(requestPromises); // If a MessageChannel was used, reply to the message on success.\n\n          if (event.ports && event.ports[0]) {\n            void requestPromises.then(function () {\n              return event.ports[0].postMessage(true);\n            });\n          }\n        }\n      });\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle.\n     * @param {ExtendableEvent} options.event The event that triggered the\n     *     request.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(_ref) {\n      var _this3 = this;\n\n      var request = _ref.request,\n          event = _ref.event;\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'handleRequest',\n          paramName: 'options.request'\n        });\n      }\n\n      var url = new URL(request.url, location.href);\n\n      if (!url.protocol.startsWith('http')) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"Workbox Router only supports URLs that start with 'http'.\");\n        }\n\n        return;\n      }\n\n      var sameOrigin = url.origin === location.origin;\n\n      var _this$findMatchingRou = this.findMatchingRoute({\n        event: event,\n        request: request,\n        sameOrigin: sameOrigin,\n        url: url\n      }),\n          params = _this$findMatchingRou.params,\n          route = _this$findMatchingRou.route;\n\n      var handler = route && route.handler;\n      var debugMessages = [];\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (handler) {\n          debugMessages.push([\"Found a route to handle this request:\", route]);\n\n          if (params) {\n            debugMessages.push([\"Passing the following params to the route's handler:\", params]);\n          }\n        }\n      } // If we don't have a handler because there was no matching route, then\n      // fall back to defaultHandler if that's defined.\n\n\n      var method = request.method;\n\n      if (!handler && this._defaultHandlerMap.has(method)) {\n        if (process.env.NODE_ENV !== 'production') {\n          debugMessages.push(\"Failed to find a matching route. Falling \" + \"back to the default handler for \".concat(method, \".\"));\n        }\n\n        handler = this._defaultHandlerMap.get(method);\n      }\n\n      if (!handler) {\n        if (process.env.NODE_ENV !== 'production') {\n          // No handler so Workbox will do nothing. If logs is set of debug\n          // i.e. verbose, we should print out this information.\n          logger.debug(\"No route found for: \".concat(getFriendlyURL(url)));\n        }\n\n        return;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        // We have a handler, meaning Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(\"Router is responding to: \".concat(getFriendlyURL(url)));\n        debugMessages.forEach(function (msg) {\n          if (Array.isArray(msg)) {\n            logger.log.apply(logger, _toConsumableArray(msg));\n          } else {\n            logger.log(msg);\n          }\n        });\n        logger.groupEnd();\n      } // Wrap in try and catch in case the handle method throws a synchronous\n      // error. It should still callback to the catch handler.\n\n\n      var responsePromise;\n\n      try {\n        responsePromise = handler.handle({\n          url: url,\n          request: request,\n          event: event,\n          params: params\n        });\n      } catch (err) {\n        responsePromise = Promise.reject(err);\n      } // Get route's catch handler, if it exists\n\n\n      var catchHandler = route && route.catchHandler;\n\n      if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n        responsePromise = responsePromise.catch( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(err) {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (!catchHandler) {\n                      _context.next = 11;\n                      break;\n                    }\n\n                    if (process.env.NODE_ENV !== 'production') {\n                      // Still include URL here as it will be async from the console group\n                      // and may not make sense without the URL\n                      logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to route's Catch Handler.\"));\n                      logger.error(\"Error thrown by:\", route);\n                      logger.error(err);\n                      logger.groupEnd();\n                    }\n\n                    _context.prev = 2;\n                    _context.next = 5;\n                    return catchHandler.handle({\n                      url: url,\n                      request: request,\n                      event: event,\n                      params: params\n                    });\n\n                  case 5:\n                    return _context.abrupt(\"return\", _context.sent);\n\n                  case 8:\n                    _context.prev = 8;\n                    _context.t0 = _context[\"catch\"](2);\n\n                    if (_context.t0 instanceof Error) {\n                      err = _context.t0;\n                    }\n\n                  case 11:\n                    if (!_this3._catchHandler) {\n                      _context.next = 14;\n                      break;\n                    }\n\n                    if (process.env.NODE_ENV !== 'production') {\n                      // Still include URL here as it will be async from the console group\n                      // and may not make sense without the URL\n                      logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to global Catch Handler.\"));\n                      logger.error(\"Error thrown by:\", route);\n                      logger.error(err);\n                      logger.groupEnd();\n                    }\n\n                    return _context.abrupt(\"return\", _this3._catchHandler.handle({\n                      url: url,\n                      request: request,\n                      event: event\n                    }));\n\n                  case 14:\n                    throw err;\n\n                  case 15:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, null, [[2, 8]]);\n          }));\n\n          return function (_x) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      }\n\n      return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n     *     against the current origin.\n     * @param {Request} options.request The request to match.\n     * @param {Event} options.event The corresponding event.\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n\n  }, {\n    key: \"findMatchingRoute\",\n    value: function findMatchingRoute(_ref3) {\n      var url = _ref3.url,\n          sameOrigin = _ref3.sameOrigin,\n          request = _ref3.request,\n          event = _ref3.event;\n      var routes = this._routes.get(request.method) || [];\n\n      var _iterator = _createForOfIteratorHelper(routes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var route = _step.value;\n          var params = void 0; // route.match returns type any, not possible to change right now.\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n          var matchResult = route.match({\n            url: url,\n            sameOrigin: sameOrigin,\n            request: request,\n            event: event\n          });\n\n          if (matchResult) {\n            if (process.env.NODE_ENV !== 'production') {\n              // Warn developers that using an async matchCallback is almost always\n              // not the right thing to do.\n              if (matchResult instanceof Promise) {\n                logger.warn(\"While routing \".concat(getFriendlyURL(url), \", an async \") + \"matchCallback function was used. Please convert the \" + \"following route to use a synchronous matchCallback function:\", route);\n              }\n            } // See https://github.com/GoogleChrome/workbox/issues/2079\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\n            params = matchResult;\n\n            if (Array.isArray(params) && params.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              params = undefined;\n            } else if (matchResult.constructor === Object && // eslint-disable-line\n            Object.keys(matchResult).length === 0) {\n              // Instead of passing an empty object in as params, use undefined.\n              params = undefined;\n            } else if (typeof matchResult === 'boolean') {\n              // For the boolean value true (rather than just something truth-y),\n              // don't set params.\n              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n              params = undefined;\n            } // Return early if have a match.\n\n\n            return {\n              route: route,\n              params: params\n            };\n          }\n        } // If no match was found above, return and empty object.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to associate with this\n     * default handler. Each method has its own default.\n     */\n\n  }, {\n    key: \"setDefaultHandler\",\n    value: function setDefaultHandler(handler) {\n      var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMethod;\n\n      this._defaultHandlerMap.set(method, normalizeHandler(handler));\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n\n  }, {\n    key: \"setCatchHandler\",\n    value: function setCatchHandler(handler) {\n      this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to register.\n     */\n\n  }, {\n    key: \"registerRoute\",\n    value: function registerRoute(route) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(route, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route, 'match', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.isType(route.handler, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route.handler, 'handle', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.handler'\n        });\n        assert.isType(route.method, 'string', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.method'\n        });\n      }\n\n      if (!this._routes.has(route.method)) {\n        this._routes.set(route.method, []);\n      } // Give precedence to all of the earlier routes by adding this additional\n      // route to the end of the array.\n\n\n      this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to unregister.\n     */\n\n  }, {\n    key: \"unregisterRoute\",\n    value: function unregisterRoute(route) {\n      if (!this._routes.has(route.method)) {\n        throw new WorkboxError('unregister-route-but-not-found-with-method', {\n          method: route.method\n        });\n      }\n\n      var routeIndex = this._routes.get(route.method).indexOf(route);\n\n      if (routeIndex > -1) {\n        this._routes.get(route.method).splice(routeIndex, 1);\n      } else {\n        throw new WorkboxError('unregister-route-route-not-registered');\n      }\n    }\n  }]);\n\n  return Router;\n}();\n\nexport { Router };","map":{"version":3,"names":["assert","getFriendlyURL","defaultMethod","logger","normalizeHandler","WorkboxError","Router","_routes","Map","_defaultHandlerMap","self","addEventListener","event","request","responsePromise","handleRequest","respondWith","data","type","payload","process","env","NODE_ENV","debug","urlsToCache","requestPromises","Promise","all","map","entry","Request","waitUntil","ports","then","postMessage","isInstance","moduleName","className","funcName","paramName","url","URL","location","href","protocol","startsWith","sameOrigin","origin","findMatchingRoute","params","route","handler","debugMessages","push","method","has","get","groupCollapsed","forEach","msg","Array","isArray","log","groupEnd","handle","err","reject","catchHandler","_catchHandler","catch","error","Error","routes","matchResult","match","warn","length","undefined","constructor","Object","keys","set","isType","hasMethod","routeIndex","indexOf","splice"],"sources":["/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/workbox-routing/Router.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * The Router can be used to process a `FetchEvent` using one or more\n * {@link workbox-routing.Route}, responding with a `Response` if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox-routing\n */\nclass Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n    }\n    /**\n     * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n    get routes() {\n        return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n    addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', ((event) => {\n            const { request } = event;\n            const responsePromise = this.handleRequest({ request, event });\n            if (responsePromise) {\n                event.respondWith(responsePromise);\n            }\n        }));\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n    addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', ((event) => {\n            // event.data is type 'any'\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (event.data && event.data.type === 'CACHE_URLS') {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const { payload } = event.data;\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n                }\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n                    if (typeof entry === 'string') {\n                        entry = [entry];\n                    }\n                    const request = new Request(...entry);\n                    return this.handleRequest({ request, event });\n                    // TODO(philipwalton): TypeScript errors without this typecast for\n                    // some reason (probably a bug). The real type here should work but\n                    // doesn't: `Array<Promise<Response> | undefined>`.\n                })); // TypeScript\n                event.waitUntil(requestPromises);\n                // If a MessageChannel was used, reply to the message on success.\n                if (event.ports && event.ports[0]) {\n                    void requestPromises.then(() => event.ports[0].postMessage(true));\n                }\n            }\n        }));\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle.\n     * @param {ExtendableEvent} options.event The event that triggered the\n     *     request.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n    handleRequest({ request, event, }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'handleRequest',\n                paramName: 'options.request',\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n            }\n            return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const { params, route } = this.findMatchingRoute({\n            event,\n            request,\n            sameOrigin,\n            url,\n        });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        if (process.env.NODE_ENV !== 'production') {\n            if (handler) {\n                debugMessages.push([`Found a route to handle this request:`, route]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`,\n                        params,\n                    ]);\n                }\n            }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n            if (process.env.NODE_ENV !== 'production') {\n                debugMessages.push(`Failed to find a matching route. Falling ` +\n                    `back to the default handler for ${method}.`);\n            }\n            handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== 'production') {\n                // No handler so Workbox will do nothing. If logs is set of debug\n                // i.e. verbose, we should print out this information.\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // We have a handler, meaning Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            debugMessages.forEach((msg) => {\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                }\n                else {\n                    logger.log(msg);\n                }\n            });\n            logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({ url, request, event, params });\n        }\n        catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        // Get route's catch handler, if it exists\n        const catchHandler = route && route.catchHandler;\n        if (responsePromise instanceof Promise &&\n            (this._catchHandler || catchHandler)) {\n            responsePromise = responsePromise.catch(async (err) => {\n                // If there's a route catch handler, process that first\n                if (catchHandler) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // Still include URL here as it will be async from the console group\n                        // and may not make sense without the URL\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\n                            ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n                        logger.error(`Error thrown by:`, route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    try {\n                        return await catchHandler.handle({ url, request, event, params });\n                    }\n                    catch (catchErr) {\n                        if (catchErr instanceof Error) {\n                            err = catchErr;\n                        }\n                    }\n                }\n                if (this._catchHandler) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // Still include URL here as it will be async from the console group\n                        // and may not make sense without the URL\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\n                            ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n                        logger.error(`Error thrown by:`, route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    return this._catchHandler.handle({ url, request, event });\n                }\n                throw err;\n            });\n        }\n        return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n     *     against the current origin.\n     * @param {Request} options.request The request to match.\n     * @param {Event} options.event The corresponding event.\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n    findMatchingRoute({ url, sameOrigin, request, event, }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n            let params;\n            // route.match returns type any, not possible to change right now.\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const matchResult = route.match({ url, sameOrigin, request, event });\n            if (matchResult) {\n                if (process.env.NODE_ENV !== 'production') {\n                    // Warn developers that using an async matchCallback is almost always\n                    // not the right thing to do.\n                    if (matchResult instanceof Promise) {\n                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +\n                            `matchCallback function was used. Please convert the ` +\n                            `following route to use a synchronous matchCallback function:`, route);\n                    }\n                }\n                // See https://github.com/GoogleChrome/workbox/issues/2079\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                params = matchResult;\n                if (Array.isArray(params) && params.length === 0) {\n                    // Instead of passing an empty array in as params, use undefined.\n                    params = undefined;\n                }\n                else if (matchResult.constructor === Object && // eslint-disable-line\n                    Object.keys(matchResult).length === 0) {\n                    // Instead of passing an empty object in as params, use undefined.\n                    params = undefined;\n                }\n                else if (typeof matchResult === 'boolean') {\n                    // For the boolean value true (rather than just something truth-y),\n                    // don't set params.\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n                    params = undefined;\n                }\n                // Return early if have a match.\n                return { route, params };\n            }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to associate with this\n     * default handler. Each method has its own default.\n     */\n    setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to register.\n     */\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(route, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route, 'match', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.isType(route.handler, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route.handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.handler',\n            });\n            assert.isType(route.method, 'string', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.method',\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to unregister.\n     */\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\n                method: route.method,\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        }\n        else {\n            throw new WorkboxError('unregister-route-route-not-registered');\n        }\n    }\n}\nexport { Router };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}