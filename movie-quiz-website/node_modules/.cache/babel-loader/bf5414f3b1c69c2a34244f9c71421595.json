{"ast":null,"code":"import _regeneratorRuntime from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\n\nvar Strategy = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of the strategy and sets all documented option\n   * properties as public instance properties.\n   *\n   * Note: if a custom strategy class extends the base Strategy class and does\n   * not need more than these properties, it does not need to define its own\n   * constructor.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   */\n  function Strategy() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Strategy);\n\n    /**\n     * Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     *\n     * @type {string}\n     */\n    this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n    /**\n     * The list\n     * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * used by this strategy.\n     *\n     * @type {Array<Object>}\n     */\n\n    this.plugins = options.plugins || [];\n    /**\n     * Values passed along to the\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n     * of all fetch() requests made by this strategy.\n     *\n     * @type {Object}\n     */\n\n    this.fetchOptions = options.fetchOptions;\n    /**\n     * The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     *\n     * @type {Object}\n     */\n\n    this.matchOptions = options.matchOptions;\n  }\n  /**\n   * Perform a request strategy and returns a `Promise` that will resolve with\n   * a `Response`, invoking all relevant plugin callbacks.\n   *\n   * When a strategy instance is registered with a Workbox\n   * {@link workbox-routing.Route}, this method is automatically\n   * called when the route matches.\n   *\n   * Alternatively, this method can be used in a standalone `FetchEvent`\n   * listener by passing it to `event.respondWith()`.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   */\n\n\n  _createClass(Strategy, [{\n    key: \"handle\",\n    value: function handle(options) {\n      var _this$handleAll = this.handleAll(options),\n          _this$handleAll2 = _slicedToArray(_this$handleAll, 1),\n          responseDone = _this$handleAll2[0];\n\n      return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n\n  }, {\n    key: \"handleAll\",\n    value: function handleAll(options) {\n      // Allow for flexible options to be passed.\n      if (options instanceof FetchEvent) {\n        options = {\n          event: options,\n          request: options.request\n        };\n      }\n\n      var event = options.event;\n      var request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n      var params = 'params' in options ? options.params : undefined;\n      var handler = new StrategyHandler(this, {\n        event: event,\n        request: request,\n        params: params\n      });\n\n      var responseDone = this._getResponse(handler, request, event);\n\n      var handlerDone = this._awaitComplete(responseDone, handler, request, event); // Return an array of promises, suitable for use with Promise.all().\n\n\n      return [responseDone, handlerDone];\n    }\n  }, {\n    key: \"_getResponse\",\n    value: function () {\n      var _getResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(handler, request, event) {\n        var response, _iterator, _step, callback, _iterator2, _step2, _callback;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return handler.runCallbacks('handlerWillStart', {\n                  event: event,\n                  request: request\n                });\n\n              case 2:\n                response = undefined;\n                _context.prev = 3;\n                _context.next = 6;\n                return this._handle(request, handler);\n\n              case 6:\n                response = _context.sent;\n\n                if (!(!response || response.type === 'error')) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new WorkboxError('no-response', {\n                  url: request.url\n                });\n\n              case 9:\n                _context.next = 39;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](3);\n\n                if (!(_context.t0 instanceof Error)) {\n                  _context.next = 34;\n                  break;\n                }\n\n                _iterator = _createForOfIteratorHelper(handler.iterateCallbacks('handlerDidError'));\n                _context.prev = 15;\n\n                _iterator.s();\n\n              case 17:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 26;\n                  break;\n                }\n\n                callback = _step.value;\n                _context.next = 21;\n                return callback({\n                  error: _context.t0,\n                  event: event,\n                  request: request\n                });\n\n              case 21:\n                response = _context.sent;\n\n                if (!response) {\n                  _context.next = 24;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 26);\n\n              case 24:\n                _context.next = 17;\n                break;\n\n              case 26:\n                _context.next = 31;\n                break;\n\n              case 28:\n                _context.prev = 28;\n                _context.t1 = _context[\"catch\"](15);\n\n                _iterator.e(_context.t1);\n\n              case 31:\n                _context.prev = 31;\n\n                _iterator.f();\n\n                return _context.finish(31);\n\n              case 34:\n                if (response) {\n                  _context.next = 38;\n                  break;\n                }\n\n                throw _context.t0;\n\n              case 38:\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.log(\"While responding to '\".concat(getFriendlyURL(request.url), \"', \") + \"an \".concat(_context.t0 instanceof Error ? _context.t0.toString() : '', \" error occurred. Using a fallback response provided by \") + \"a handlerDidError plugin.\");\n                }\n\n              case 39:\n                _iterator2 = _createForOfIteratorHelper(handler.iterateCallbacks('handlerWillRespond'));\n                _context.prev = 40;\n\n                _iterator2.s();\n\n              case 42:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 49;\n                  break;\n                }\n\n                _callback = _step2.value;\n                _context.next = 46;\n                return _callback({\n                  event: event,\n                  request: request,\n                  response: response\n                });\n\n              case 46:\n                response = _context.sent;\n\n              case 47:\n                _context.next = 42;\n                break;\n\n              case 49:\n                _context.next = 54;\n                break;\n\n              case 51:\n                _context.prev = 51;\n                _context.t2 = _context[\"catch\"](40);\n\n                _iterator2.e(_context.t2);\n\n              case 54:\n                _context.prev = 54;\n\n                _iterator2.f();\n\n                return _context.finish(54);\n\n              case 57:\n                return _context.abrupt(\"return\", response);\n\n              case 58:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 11], [15, 28, 31, 34], [40, 51, 54, 57]]);\n      }));\n\n      function _getResponse(_x, _x2, _x3) {\n        return _getResponse2.apply(this, arguments);\n      }\n\n      return _getResponse;\n    }()\n  }, {\n    key: \"_awaitComplete\",\n    value: function () {\n      var _awaitComplete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(responseDone, handler, request, event) {\n        var response, error;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return responseDone;\n\n              case 3:\n                response = _context2.sent;\n                _context2.next = 8;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](0);\n\n              case 8:\n                _context2.prev = 8;\n                _context2.next = 11;\n                return handler.runCallbacks('handlerDidRespond', {\n                  event: event,\n                  request: request,\n                  response: response\n                });\n\n              case 11:\n                _context2.next = 13;\n                return handler.doneWaiting();\n\n              case 13:\n                _context2.next = 18;\n                break;\n\n              case 15:\n                _context2.prev = 15;\n                _context2.t1 = _context2[\"catch\"](8);\n\n                if (_context2.t1 instanceof Error) {\n                  error = _context2.t1;\n                }\n\n              case 18:\n                _context2.next = 20;\n                return handler.runCallbacks('handlerDidComplete', {\n                  event: event,\n                  request: request,\n                  response: response,\n                  error: error\n                });\n\n              case 20:\n                handler.destroy();\n\n                if (!error) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                throw error;\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 6], [8, 15]]);\n      }));\n\n      function _awaitComplete(_x4, _x5, _x6, _x7) {\n        return _awaitComplete2.apply(this, arguments);\n      }\n\n      return _awaitComplete;\n    }()\n  }]);\n\n  return Strategy;\n}();\n\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */","map":{"version":3,"names":["cacheNames","WorkboxError","logger","getFriendlyURL","StrategyHandler","Strategy","options","cacheName","getRuntimeName","plugins","fetchOptions","matchOptions","handleAll","responseDone","FetchEvent","event","request","Request","params","undefined","handler","_getResponse","handlerDone","_awaitComplete","runCallbacks","response","_handle","type","url","Error","iterateCallbacks","callback","error","process","env","NODE_ENV","log","toString","doneWaiting","destroy"],"sources":["/home/tux/Data/dataDocuments/07-programDocs/.kProgDocs/krugTTS/TTS-foundationalCodeImmersion-2022/MovieQuizWebsite/movie-quiz-website/node_modules/workbox-strategies/Strategy.js"],"sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * {@link workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string'\n            ? new Request(options.request)\n            : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                    response = await callback({ error, event, request });\n                    if (response) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error: error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,UAAT,QAA2B,qCAA3B;AACA,SAASC,YAAT,QAA6B,uCAA7B;AACA,SAASC,MAAT,QAAuB,iCAAvB;AACA,SAASC,cAAT,QAA+B,yCAA/B;AACA,SAASC,eAAT,QAAgC,sBAAhC;AACA,OAAO,eAAP;AACA;AACA;AACA;AACA;AACA;;IACMC,Q;EACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,oBAA0B;IAAA,IAAdC,OAAc,uEAAJ,EAAI;;IAAA;;IACtB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,KAAKC,SAAL,GAAiBP,UAAU,CAACQ,cAAX,CAA0BF,OAAO,CAACC,SAAlC,CAAjB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKE,OAAL,GAAeH,OAAO,CAACG,OAAR,IAAmB,EAAlC;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,YAAL,GAAoBJ,OAAO,CAACI,YAA5B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,YAAL,GAAoBL,OAAO,CAACK,YAA5B;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACI,gBAAOL,OAAP,EAAgB;MACZ,sBAAuB,KAAKM,SAAL,CAAeN,OAAf,CAAvB;MAAA;MAAA,IAAOO,YAAP;;MACA,OAAOA,YAAP;IACH;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,mBAAUP,OAAV,EAAmB;MACf;MACA,IAAIA,OAAO,YAAYQ,UAAvB,EAAmC;QAC/BR,OAAO,GAAG;UACNS,KAAK,EAAET,OADD;UAENU,OAAO,EAAEV,OAAO,CAACU;QAFX,CAAV;MAI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"},"metadata":{},"sourceType":"module"}